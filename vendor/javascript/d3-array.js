// d3-array@2.12.1 downloaded from https://ga.jspm.io/npm:d3-array@2.12.1/dist/d3-array.js

var e={};(function(t,n){n(e)})(0,(function(e){function ascending(e,t){return e<t?-1:e>t?1:e>=t?0:NaN}function bisector(e){let t=e;let n=e;if(1===e.length){t=(t,n)=>e(t)-n;n=ascendingComparator(e)}function left(e,t,r,o){null==r&&(r=0);null==o&&(o=e.length);while(r<o){const i=r+o>>>1;n(e[i],t)<0?r=i+1:o=i}return r}function right(e,t,r,o){null==r&&(r=0);null==o&&(o=e.length);while(r<o){const i=r+o>>>1;n(e[i],t)>0?o=i:r=i+1}return r}function center(e,n,r,o){null==r&&(r=0);null==o&&(o=e.length);const i=left(e,n,r,o-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i}return{left:left,center:center,right:right}}function ascendingComparator(e){return(t,n)=>ascending(e(t),n)}function number(e){return null===e?NaN:+e}function*numbers(e,t){if(void 0===t)for(let t of e)null!=t&&(t=+t)>=t&&(yield t);else{let n=-1;for(let r of e)null!=(r=t(r,++n,e))&&(r=+r)>=r&&(yield r)}}const t=bisector(ascending);const n=t.right;const r=t.left;const o=bisector(number).center;function count(e,t){let n=0;if(void 0===t)for(let t of e)null!=t&&(t=+t)>=t&&++n;else{let r=-1;for(let o of e)null!=(o=t(o,++r,e))&&(o=+o)>=o&&++n}return n}function length$1(e){return 0|e.length}function empty(e){return!(e>0)}function arrayify(e){return"object"!==typeof e||"length"in e?e:Array.from(e)}function reducer(e){return t=>e(...t)}function cross(...e){const t="function"===typeof e[e.length-1]&&reducer(e.pop());e=e.map(arrayify);const n=e.map(length$1);const r=e.length-1;const o=new Array(r+1).fill(0);const i=[];if(r<0||n.some(empty))return i;while(true){i.push(o.map(((t,n)=>e[n][t])));let s=r;while(++o[s]===n[s]){if(0===s)return t?i.map(t):i;o[s--]=0}}}function cumsum(e,t){var n=0,r=0;return Float64Array.from(e,void 0===t?e=>n+=+e||0:o=>n+=+t(o,r++,e)||0)}function descending(e,t){return t<e?-1:t>e?1:t>=e?0:NaN}function variance(e,t){let n=0;let r;let o=0;let i=0;if(void 0===t){for(let t of e)if(null!=t&&(t=+t)>=t){r=t-o;o+=r/++n;i+=r*(t-o)}}else{let s=-1;for(let u of e)if(null!=(u=t(u,++s,e))&&(u=+u)>=u){r=u-o;o+=r/++n;i+=r*(u-o)}}if(n>1)return i/(n-1)}function deviation(e,t){const n=variance(e,t);return n?Math.sqrt(n):n}function extent(e,t){let n;let r;if(void 0===t){for(const t of e)if(null!=t)if(void 0===n)t>=t&&(n=r=t);else{n>t&&(n=t);r<t&&(r=t)}}else{let o=-1;for(let i of e)if(null!=(i=t(i,++o,e)))if(void 0===n)i>=i&&(n=r=i);else{n>i&&(n=i);r<i&&(r=i)}}return[n,r]}class Adder{constructor(){this._partials=new Float64Array(32);this._n=0}add(e){const t=this._partials;let n=0;for(let r=0;r<this._n&&r<32;r++){const o=t[r],i=e+o,s=Math.abs(e)<Math.abs(o)?e-(i-o):o-(i-e);s&&(t[n++]=s);e=i}t[n]=e;this._n=n+1;return this}valueOf(){const e=this._partials;let t,n,r,o=this._n,i=0;if(o>0){i=e[--o];while(o>0){t=i;n=e[--o];i=t+n;r=n-(i-t);if(r)break}if(o>0&&(r<0&&e[o-1]<0||r>0&&e[o-1]>0)){n=2*r;t=i+n;n==t-i&&(i=t)}}return i}}function fsum(e,t){const n=new Adder;if(void 0===t)for(let t of e)(t=+t)&&n.add(t);else{let r=-1;for(let o of e)(o=+t(o,++r,e))&&n.add(o)}return+n}function fcumsum(e,t){const n=new Adder;let r=-1;return Float64Array.from(e,void 0===t?e=>n.add(+e||0):o=>n.add(+t(o,++r,e)||0))}class InternMap extends Map{constructor(e,t=keyof){super();Object.defineProperties(this,{_intern:{value:new Map},_key:{value:t}});if(null!=e)for(const[t,n]of e)this.set(t,n)}get(e){return super.get(intern_get(this,e))}has(e){return super.has(intern_get(this,e))}set(e,t){return super.set(intern_set(this,e),t)}delete(e){return super.delete(intern_delete(this,e))}}class InternSet extends Set{constructor(e,t=keyof){super();Object.defineProperties(this,{_intern:{value:new Map},_key:{value:t}});if(null!=e)for(const t of e)this.add(t)}has(e){return super.has(intern_get(this,e))}add(e){return super.add(intern_set(this,e))}delete(e){return super.delete(intern_delete(this,e))}}function intern_get({_intern:e,_key:t},n){const r=t(n);return e.has(r)?e.get(r):n}function intern_set({_intern:e,_key:t},n){const r=t(n);if(e.has(r))return e.get(r);e.set(r,n);return n}function intern_delete({_intern:e,_key:t},n){const r=t(n);if(e.has(r)){n=e.get(n);e.delete(r)}return n}function keyof(e){return null!==e&&"object"===typeof e?e.valueOf():e}function identity(e){return e}function group(e,...t){return nest(e,identity,identity,t)}function groups(e,...t){return nest(e,Array.from,identity,t)}function rollup(e,t,...n){return nest(e,identity,t,n)}function rollups(e,t,...n){return nest(e,Array.from,t,n)}function index(e,...t){return nest(e,identity,unique,t)}function indexes(e,...t){return nest(e,Array.from,unique,t)}function unique(e){if(1!==e.length)throw new Error("duplicate key");return e[0]}function nest(e,t,n,r){return function regroup(e,o){if(o>=r.length)return n(e);const i=new InternMap;const s=r[o++];let u=-1;for(const t of e){const n=s(t,++u,e);const r=i.get(n);r?r.push(t):i.set(n,[t])}for(const[e,t]of i)i.set(e,regroup(t,o));return t(i)}(e,0)}function permute(e,t){return Array.from(t,(t=>e[t]))}function sort(e,...t){if("function"!==typeof e[Symbol.iterator])throw new TypeError("values is not iterable");e=Array.from(e);let[n=ascending]=t;if(1===n.length||t.length>1){const r=Uint32Array.from(e,((e,t)=>t));if(t.length>1){t=t.map((t=>e.map(t)));r.sort(((e,n)=>{for(const r of t){const t=ascending(r[e],r[n]);if(t)return t}}))}else{n=e.map(n);r.sort(((e,t)=>ascending(n[e],n[t])))}return permute(e,r)}return e.sort(n)}function groupSort(e,t,n){return(1===t.length?sort(rollup(e,t,n),(([e,t],[n,r])=>ascending(t,r)||ascending(e,n))):sort(group(e,n),(([e,n],[r,o])=>t(n,o)||ascending(e,r)))).map((([e])=>e))}var i=Array.prototype;var s=i.slice;function constant(e){return function(){return e}}var u=Math.sqrt(50),f=Math.sqrt(10),l=Math.sqrt(2);function ticks(e,t,n){var r,o,i,s,u=-1;t=+t,e=+e,n=+n;if(e===t&&n>0)return[e];(r=t<e)&&(o=e,e=t,t=o);if(0===(s=tickIncrement(e,t,n))||!isFinite(s))return[];if(s>0){let n=Math.round(e/s),r=Math.round(t/s);n*s<e&&++n;r*s>t&&--r;i=new Array(o=r-n+1);while(++u<o)i[u]=(n+u)*s}else{s=-s;let n=Math.round(e*s),r=Math.round(t*s);n/s<e&&++n;r/s>t&&--r;i=new Array(o=r-n+1);while(++u<o)i[u]=(n+u)/s}r&&i.reverse();return i}function tickIncrement(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),i=r/Math.pow(10,o);return o>=0?(i>=u?10:i>=f?5:i>=l?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(i>=u?10:i>=f?5:i>=l?2:1)}function tickStep(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),i=r/o;i>=u?o*=10:i>=f?o*=5:i>=l&&(o*=2);return t<e?-o:o}function nice(e,t,n){let r;while(true){const o=tickIncrement(e,t,n);if(o===r||0===o||!isFinite(o))return[e,t];if(o>0){e=Math.floor(e/o)*o;t=Math.ceil(t/o)*o}else if(o<0){e=Math.ceil(e*o)/o;t=Math.floor(t*o)/o}r=o}}function sturges(e){return Math.ceil(Math.log(count(e))/Math.LN2)+1}function bin(){var e=identity,t=extent,r=sturges;function histogram(o){Array.isArray(o)||(o=Array.from(o));var i,s,u=o.length,f=new Array(u);for(i=0;i<u;++i)f[i]=e(o[i],i,o);var l=t(f),c=l[0],a=l[1],d=r(f,c,a);if(!Array.isArray(d)){const e=a,n=+d;t===extent&&([c,a]=nice(c,a,n));d=ticks(c,a,n);if(d[d.length-1]>=a)if(e>=a&&t===extent){const e=tickIncrement(c,a,n);isFinite(e)&&(e>0?a=(Math.floor(a/e)+1)*e:e<0&&(a=(Math.ceil(a*-e)+1)/-e))}else d.pop()}var h=d.length;while(d[0]<=c)d.shift(),--h;while(d[h-1]>a)d.pop(),--h;var p,m=new Array(h+1);for(i=0;i<=h;++i){p=m[i]=[];p.x0=i>0?d[i-1]:c;p.x1=i<h?d[i]:a}for(i=0;i<u;++i){s=f[i];c<=s&&s<=a&&m[n(d,s,0,h)].push(o[i])}return m}histogram.value=function(t){return arguments.length?(e="function"===typeof t?t:constant(t),histogram):e};histogram.domain=function(e){return arguments.length?(t="function"===typeof e?e:constant([e[0],e[1]]),histogram):t};histogram.thresholds=function(e){return arguments.length?(r="function"===typeof e?e:Array.isArray(e)?constant(s.call(e)):constant(e),histogram):r};return histogram}function max(e,t){let n;if(void 0===t)for(const t of e)null!=t&&(n<t||void 0===n&&t>=t)&&(n=t);else{let r=-1;for(let o of e)null!=(o=t(o,++r,e))&&(n<o||void 0===n&&o>=o)&&(n=o)}return n}function min(e,t){let n;if(void 0===t)for(const t of e)null!=t&&(n>t||void 0===n&&t>=t)&&(n=t);else{let r=-1;for(let o of e)null!=(o=t(o,++r,e))&&(n>o||void 0===n&&o>=o)&&(n=o)}return n}function quickselect(e,t,n=0,r=e.length-1,o=ascending){while(r>n){if(r-n>600){const i=r-n+1;const s=t-n+1;const u=Math.log(i);const f=.5*Math.exp(2*u/3);const l=.5*Math.sqrt(u*f*(i-f)/i)*(s-i/2<0?-1:1);const c=Math.max(n,Math.floor(t-s*f/i+l));const a=Math.min(r,Math.floor(t+(i-s)*f/i+l));quickselect(e,t,c,a,o)}const i=e[t];let s=n;let u=r;swap(e,n,t);o(e[r],i)>0&&swap(e,n,r);while(s<u){swap(e,s,u),++s,--u;while(o(e[s],i)<0)++s;while(o(e[u],i)>0)--u}0===o(e[n],i)?swap(e,n,u):(++u,swap(e,u,r));u<=t&&(n=u+1);t<=u&&(r=u-1)}return e}function swap(e,t,n){const r=e[t];e[t]=e[n];e[n]=r}function quantile(e,t,n){e=Float64Array.from(numbers(e,n));if(r=e.length){if((t=+t)<=0||r<2)return min(e);if(t>=1)return max(e);var r,o=(r-1)*t,i=Math.floor(o),s=max(quickselect(e,i).subarray(0,i+1)),u=min(e.subarray(i+1));return s+(u-s)*(o-i)}}function quantileSorted(e,t,n=number){if(r=e.length){if((t=+t)<=0||r<2)return+n(e[0],0,e);if(t>=1)return+n(e[r-1],r-1,e);var r,o=(r-1)*t,i=Math.floor(o),s=+n(e[i],i,e),u=+n(e[i+1],i+1,e);return s+(u-s)*(o-i)}}function freedmanDiaconis(e,t,n){return Math.ceil((n-t)/(2*(quantile(e,.75)-quantile(e,.25))*Math.pow(count(e),-1/3)))}function scott(e,t,n){return Math.ceil((n-t)/(3.5*deviation(e)*Math.pow(count(e),-1/3)))}function maxIndex(e,t){let n;let r=-1;let o=-1;if(void 0===t)for(const t of e){++o;null!=t&&(n<t||void 0===n&&t>=t)&&(n=t,r=o)}else for(let i of e)null!=(i=t(i,++o,e))&&(n<i||void 0===n&&i>=i)&&(n=i,r=o);return r}function mean(e,t){let n=0;let r=0;if(void 0===t)for(let t of e)null!=t&&(t=+t)>=t&&(++n,r+=t);else{let o=-1;for(let i of e)null!=(i=t(i,++o,e))&&(i=+i)>=i&&(++n,r+=i)}if(n)return r/n}function median(e,t){return quantile(e,.5,t)}function*flatten(e){for(const t of e)yield*t}function merge(e){return Array.from(flatten(e))}function minIndex(e,t){let n;let r=-1;let o=-1;if(void 0===t)for(const t of e){++o;null!=t&&(n>t||void 0===n&&t>=t)&&(n=t,r=o)}else for(let i of e)null!=(i=t(i,++o,e))&&(n>i||void 0===n&&i>=i)&&(n=i,r=o);return r}function pairs(e,t=pair){const n=[];let r;let o=false;for(const i of e){o&&n.push(t(r,i));r=i;o=true}return n}function pair(e,t){return[e,t]}function range(e,t,n){e=+e,t=+t,n=(o=arguments.length)<2?(t=e,e=0,1):o<3?1:+n;var r=-1,o=0|Math.max(0,Math.ceil((t-e)/n)),i=new Array(o);while(++r<o)i[r]=e+r*n;return i}function least(e,t=ascending){let n;let r=false;if(1===t.length){let o;for(const i of e){const e=t(i);if(r?ascending(e,o)<0:0===ascending(e,e)){n=i;o=e;r=true}}}else for(const o of e)if(r?t(o,n)<0:0===t(o,o)){n=o;r=true}return n}function leastIndex(e,t=ascending){if(1===t.length)return minIndex(e,t);let n;let r=-1;let o=-1;for(const i of e){++o;if(r<0?0===t(i,i):t(i,n)<0){n=i;r=o}}return r}function greatest(e,t=ascending){let n;let r=false;if(1===t.length){let o;for(const i of e){const e=t(i);if(r?ascending(e,o)>0:0===ascending(e,e)){n=i;o=e;r=true}}}else for(const o of e)if(r?t(o,n)>0:0===t(o,o)){n=o;r=true}return n}function greatestIndex(e,t=ascending){if(1===t.length)return maxIndex(e,t);let n;let r=-1;let o=-1;for(const i of e){++o;if(r<0?0===t(i,i):t(i,n)>0){n=i;r=o}}return r}function scan(e,t){const n=leastIndex(e,t);return n<0?void 0:n}var c=shuffler(Math.random);function shuffler(e){return function shuffle(t,n=0,r=t.length){let o=r-(n=+n);while(o){const r=e()*o--|0,i=t[o+n];t[o+n]=t[r+n];t[r+n]=i}return t}}function sum(e,t){let n=0;if(void 0===t)for(let t of e)(t=+t)&&(n+=t);else{let r=-1;for(let o of e)(o=+t(o,++r,e))&&(n+=o)}return n}function transpose(e){if(!(o=e.length))return[];for(var t=-1,n=min(e,length),r=new Array(n);++t<n;)for(var o,i=-1,s=r[t]=new Array(o);++i<o;)s[i]=e[i][t];return r}function length(e){return e.length}function zip(){return transpose(arguments)}function every(e,t){if("function"!==typeof t)throw new TypeError("test is not a function");let n=-1;for(const r of e)if(!t(r,++n,e))return false;return true}function some(e,t){if("function"!==typeof t)throw new TypeError("test is not a function");let n=-1;for(const r of e)if(t(r,++n,e))return true;return false}function filter(e,t){if("function"!==typeof t)throw new TypeError("test is not a function");const n=[];let r=-1;for(const o of e)t(o,++r,e)&&n.push(o);return n}function map(e,t){if("function"!==typeof e[Symbol.iterator])throw new TypeError("values is not iterable");if("function"!==typeof t)throw new TypeError("mapper is not a function");return Array.from(e,((n,r)=>t(n,r,e)))}function reduce(e,t,n){if("function"!==typeof t)throw new TypeError("reducer is not a function");const r=e[Symbol.iterator]();let o,i,s=-1;if(arguments.length<3){({done:o,value:n}=r.next());if(o)return;++s}while(({done:o,value:i}=r.next()),!o)n=t(n,i,++s,e);return n}function reverse(e){if("function"!==typeof e[Symbol.iterator])throw new TypeError("values is not iterable");return Array.from(e).reverse()}function difference(e,...t){e=new Set(e);for(const n of t)for(const t of n)e.delete(t);return e}function disjoint(e,t){const n=t[Symbol.iterator](),r=new Set;for(const t of e){if(r.has(t))return false;let e,o;while(({value:e,done:o}=n.next())){if(o)break;if(Object.is(t,e))return false;r.add(e)}}return true}function set(e){return e instanceof Set?e:new Set(e)}function intersection(e,...t){e=new Set(e);t=t.map(set);e:for(const n of e)for(const r of t)if(!r.has(n)){e.delete(n);continue e}return e}function superset(e,t){const n=e[Symbol.iterator](),r=new Set;for(const e of t){if(r.has(e))continue;let t,o;while(({value:t,done:o}=n.next())){if(o)return false;r.add(t);if(Object.is(e,t))break}}return true}function subset(e,t){return superset(t,e)}function union(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t}e.Adder=Adder;e.InternMap=InternMap;e.InternSet=InternSet;e.ascending=ascending;e.bin=bin;e.bisect=n;e.bisectCenter=o;e.bisectLeft=r;e.bisectRight=n;e.bisector=bisector;e.count=count;e.cross=cross;e.cumsum=cumsum;e.descending=descending;e.deviation=deviation;e.difference=difference;e.disjoint=disjoint;e.every=every;e.extent=extent;e.fcumsum=fcumsum;e.filter=filter;e.fsum=fsum;e.greatest=greatest;e.greatestIndex=greatestIndex;e.group=group;e.groupSort=groupSort;e.groups=groups;e.histogram=bin;e.index=index;e.indexes=indexes;e.intersection=intersection;e.least=least;e.leastIndex=leastIndex;e.map=map;e.max=max;e.maxIndex=maxIndex;e.mean=mean;e.median=median;e.merge=merge;e.min=min;e.minIndex=minIndex;e.nice=nice;e.pairs=pairs;e.permute=permute;e.quantile=quantile;e.quantileSorted=quantileSorted;e.quickselect=quickselect;e.range=range;e.reduce=reduce;e.reverse=reverse;e.rollup=rollup;e.rollups=rollups;e.scan=scan;e.shuffle=c;e.shuffler=shuffler;e.some=some;e.sort=sort;e.subset=subset;e.sum=sum;e.superset=superset;e.thresholdFreedmanDiaconis=freedmanDiaconis;e.thresholdScott=scott;e.thresholdSturges=sturges;e.tickIncrement=tickIncrement;e.tickStep=tickStep;e.ticks=ticks;e.transpose=transpose;e.union=union;e.variance=variance;e.zip=zip;Object.defineProperty(e,"__esModule",{value:true})}));const t=e.Adder,n=e.InternMap,r=e.InternSet,o=e.ascending,i=e.bin,s=e.bisect,u=e.bisectCenter,f=e.bisectLeft,l=e.bisectRight,c=e.bisector,a=e.count,d=e.cross,h=e.cumsum,p=e.descending,m=e.deviation,g=e.difference,y=e.disjoint,v=e.every,w=e.extent,x=e.fcumsum,M=e.filter,b=e.fsum,A=e.greatest,I=e.greatestIndex,k=e.group,S=e.groupSort,_=e.groups,q=e.histogram,j=e.index,E=e.indexes,F=e.intersection,N=e.least,T=e.leastIndex,O=e.map,L=e.max,z=e.maxIndex,C=e.mean,D=e.median,P=e.merge,R=e.min,$=e.minIndex,U=e.nice,B=e.pairs,G=e.permute,H=e.quantile,J=e.quantileSorted,K=e.quickselect,Q=e.range,V=e.reduce,W=e.reverse,X=e.rollup,Y=e.rollups,Z=e.scan,ee=e.shuffle,te=e.shuffler,ne=e.some,re=e.sort,oe=e.subset,ie=e.sum,se=e.superset,ue=e.thresholdFreedmanDiaconis,fe=e.thresholdScott,le=e.thresholdSturges,ce=e.tickIncrement,ae=e.tickStep,de=e.ticks,he=e.transpose,pe=e.union,me=e.variance,ge=e.zip,ye=e.__esModule;export default e;export{t as Adder,n as InternMap,r as InternSet,ye as __esModule,o as ascending,i as bin,s as bisect,u as bisectCenter,f as bisectLeft,l as bisectRight,c as bisector,a as count,d as cross,h as cumsum,p as descending,m as deviation,g as difference,y as disjoint,v as every,w as extent,x as fcumsum,M as filter,b as fsum,A as greatest,I as greatestIndex,k as group,S as groupSort,_ as groups,q as histogram,j as index,E as indexes,F as intersection,N as least,T as leastIndex,O as map,L as max,z as maxIndex,C as mean,D as median,P as merge,R as min,$ as minIndex,U as nice,B as pairs,G as permute,H as quantile,J as quantileSorted,K as quickselect,Q as range,V as reduce,W as reverse,X as rollup,Y as rollups,Z as scan,ee as shuffle,te as shuffler,ne as some,re as sort,oe as subset,ie as sum,se as superset,ue as thresholdFreedmanDiaconis,fe as thresholdScott,le as thresholdSturges,ce as tickIncrement,ae as tickStep,de as ticks,he as transpose,pe as union,me as variance,ge as zip};

